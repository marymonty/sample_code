MiniBLAST Hash: this was an assignment that utilized hash tables by taking in querys of genome sequences and hashing them. 
All the text files are for input files besides the blastHash_output.txt file which shows the output of a run. The images show my terminal output.

What I did:
I wrote a hash function myself utilizing a common hash function where I multiply values by 4 to the 0th power, 1st power, 2nd power, etc. I gave each base (a, c, g, or t) a numerical value (0, 1, 2, and 3 respectively). I used this numerical value for the letter and multiplied it by 4 to the power of the index we were at within the kmer. I had a running total and for each letter that computation was added to the total. So if the kmer was ATG then the computation would be (0*4^0) + (3*4^1) + (2*4^2) = total. I would return total and that was my index in the hash table.

My hash table was implemented by creating an array of HashKey pointers. Each HashKey held a key, which was a string (the kmer), and a vector of values, which were ints of the position in the original genome text file that the kmer showed up. I chose a vector of ints for this value in case the kmer showed up more than once in the genome file. The hash table was created by making a hash table which took in arguments of an int (the initial minimum size of the table), and a float (the occupancy of the table - needs to be set so the table can be resized later if need be). Within the constructor I initialized the table size, the number of key entries (which are the number of unique keys in the table (initialized to 0)(will be needed later for the resize function)), the occupancy, and the creation of the table, which is an array that hold HashKey pointers, this array is of the table size, then all indicies in the table are filled with NULL. My insert into the hash table take in a string that is the key (the kmer of size indicated) and consists of me getting an index, which uses the hash function to get an int which is modded by the size of the table so that the index I am trying to insert the key into is within the table bounds. Once I have this starting index, I check a few conditions, if the index in the table is not NULL, therefore it has a key already in it, then i check to see if it is the same key, if so I can just add the new position it was found in the genome text to that key's values vector. However if it is a NULL, I can create a new HashKey and insert it into that free index. If the index is not free and not the same key, I used linear probing so I would just keep going to the next index until one was free. My find is pretty much the same thing, however in find I return the vector of values, which are the positions in the genome text that the specified kmer is found at. I have two other functions of check occupancy, which checks if the table is full enough to need to be resized, and resize, which doubles the size of the old table array, and goes through and usues the hash function to insert all the old HashKeys into the larger table. Finally I have a deletion to delete the hash table if needed.
